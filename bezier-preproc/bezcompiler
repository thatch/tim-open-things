#!/usr/bin/env python2
# Usage: bezcompiler f.inc
# Writes f.inc.scad with a module called 'x'

import sys

def get_final_name(fn):
  return fn + '.scad'

def lerp(a, b, f):
  dx = b[0] - a[0]
  dy = b[1] - a[1]
  return (a[0] + f*dx, a[1] + f*dy)

def add2d(a, b):
  return a[0] + b[0], a[1] + b[1]

def invert2d(a):
  return -a[0], -a[1]

def mirror(a, relative_to):
  delta = add2d(relative_to, invert2d(a))
  return add2d(relative_to, delta)

def skip_dupe(it):
  prev = None
  for i in it:
    if i != prev:
      yield i
      prev = i

class ParseError(Exception): pass

class CubicSpline(object):
  def __init__(self, point_list):
    self.curves = []
    if len(point_list) % 3 != 1:
      raise ValueError('Wrong number of points, expected 3n+1')

    last_control_point = None
    for i in range(len(point_list)/3):
      a, b, c, d = point_list[i*3:i*3+4]
      if b is None:
        b = mirror(last_control_point, a)

      self.curves.append([a, b, c, d])
      last_control_point = c


class Bezier(object):
  """Represents a bezier curve of arbitrary degree."""

  def __init__(self):
    self.error = 0.1
    self.steps = 100
    self.curves = []

  @classmethod
  def parse(cls, data):
    c = cls()
    for line in data.splitlines():
      line = line.strip()
      if line.startswith('#') or not line:
        continue
      elif '=' in line:
        key, value = line.split('=')
        if key == '$error':
          c.error = float(value)
        elif key == '$steps':
          c.steps = int(value)
        else:
          raise ParseError('Unknown command line %r' % (line,))
      else:
        # TODO handle multiple curves with hard corners
        obj = eval(line, {}, {'cubicspline': CubicSpline})
        if isinstance(obj, CubicSpline):
          c.curves.extend(obj.curves)
        else:
          c.curves.append(obj)
    return c

  def get_output(self):
    buf = []
    # TODO make this quite a bit faster
    # TODO handle $error
    for c in range(len(self.curves)):
      # Fast path for single points, explicitly tuplify for the format operator
      # to work later, and avoid doing many pointless _reduce operations.
      if len(self.curves[c]) == 1:
        buf.append(tuple(self.curves[c][0]))
      else:
        for i in xrange(self.steps+1):
          t = float(i) / self.steps
          p = self._reduce(self.curves[c], t)
          buf.append(p)

    # TODO winding order appears CW
    try:
      return ('module x() { polygon([%s], convexity=10); }\n' %
              (','.join(skip_dupe('[%.6f,%.6f]' % p for p in buf)),))
    except:
      print "Buf", buf
      raise

  @classmethod
  def _reduce(cls, points, t):
    """Basic recursive degree reduction.  Stops when it gets a single point."""
    if len(points) == 1:
      return points[0]

    b = []
    for i in range(len(points)-1):
      b.append(lerp(points[i], points[i+1], t))
    return cls._reduce(b, t)

def main(files):
  for fn in files:
    with open(fn) as f:
      data = f.read()
    b = Bezier.parse(data)
    with open(get_final_name(fn), 'w') as f:
      f.write(b.get_output())

if __name__ == '__main__':
  main(sys.argv[1:])
